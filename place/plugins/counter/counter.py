"""Demo instrument: a counter"""
# This is meant as both a test and a working demo for PLACE.
from time import sleep
import random
from threading import Thread
import mpld3
import matplotlib.pyplot as plt
import numpy as np
from obspy.core import Stream
from obspy.core.trace import Stats, Trace
from place.plugins.instrument import Instrument, send_data_thread

class Counter(Instrument):
    """A unit counter"""
    # This instrument records a unit value for each update and sleeps for a
    # specific amount of time. The unit value is placed into the header and a
    # Trace is recorded into the hdf5 file. A plot of the unit values is
    # printed to the webapp plot window.
    def __init__(self, config):
        """Initialize the counter, without configuring.

        :param config: configuration data (as a parsed JSON object)
        :type config: dict
        """
        # First, we call the base class initializer with the config data.
        Instrument.__init__(self, config)
        # Typically, PLACE instruments should be configured only when the
        # config() method is called. However, we will store the configuration
        # data here, so it is always accessible. This is technically done in
        # the base class, too, but we will do it again to document that it is
        # actually happening the way we intend. This also prevents any issues
        # if we subclass this class.
        self._config = config
        # Class variables should be set to trivial values in this method as a
        # form of documentation.
        self._count = None
        # This Stream object will hold our recorded data.
        self._stream = None
        # Additionally, minimal resource gathering is appropriate here, if
        # needed. By following this design pattern, it creates a contrast
        # between instruments which have been initialized vs. instruments which
        # have been configured, which is a subtle but important difference.
    def config(self, header=Stats()):
        """Configure the counter

        :param header: metadata for the scan
        :type header: obspy.core.trace.Stats
        """
        # At this time, it is appropriate to initialize variables to their true
        # initial values.
        # This integer will hold the current count.
        self._count = 1
        # And this Stream object will collect data during the scan.
        self._stream = Stream()
        # During the config phase, we are provided the metadata for the scan.
        # We should put any scan-wide information about our information into
        # the header at this point.
        header["counter_sleep_time"] = self._config['sleep_time']
        # Note that we have chosen to include the sleep time in the header
        # information. This means that the sleep time will be put into every
        # trace generated by all instruments during this scan.

    def update(self, header=Stats(), socket=None):
        """Update the counter

        :param header: metadata for the scan
        :type header: obspy.core.trace.Stats

        :param socket: connection to the webapp plot frame
        :type socket: websocket
        """
        # We are now in the update phase. Since our counter starts at 1, we
        # should record the data before we increment the counter. Note that we
        # don't know how many time update will be called. We simply record the
        # value and then increment.
        header['counter_current_count'] = self._count
        self._count += 1
        # Since this is a demo instrument, we also want to record a trace. We
        # will create a simple list to use as sample data. PLACE generally uses
        # NumPy arrays to store data.
        random.seed(19)
        some_data = np.array([random.random() for _ in range(1, self._count)])
        # And put this data into a Trace object and add this trace to our
        # stream of data.
        trace = Trace(some_data, header)
        self._stream.append(trace)
        # If the scan was started with the webapp, then during update, we are
        # given access to an iframe in the webapp window. Technically, it is a
        # socket to the webapp's iframe. Typically, this is used to plot data,
        # but we can send any valid HTML. We only want to do this if 'socket'
        # is not None and our instrument has been told to plot. If we have not
        # been provided a socket, we should still plot, but we will do so to
        # the current screen instead.
        if self._config['plot']:
            if not socket:
                # The user wants to plot, but we don't have a socket to send
                # data back to the webapp. Use the default matplotlib backend
                # to show the plot.
                plt.ion()
                plt.clf()
                plt.plot(some_data)
                plt.pause(0.05)
            else:
                # Send the HTML version of the plot back to the webapp. Sending
                # data over a websocket is a coroutine, and so it must be done
                # in a separate thread. However, we will wait for the tread to
                # complete before moving on.
                plt.clf()
                plt.plot(some_data)
                out = mpld3.fig_to_html(plt.gcf())
                thread = Thread(target=send_data_thread, args=(socket, out))
                thread.start()
                thread.join()
        # And now we sleep, as specified in the configuration.
        sleep(self._config['sleep_time'])

    def cleanup(self):
        """Stop the counter and return data."""
        # This method does not have any resources that need to be freed, or
        # connections that need to be closed. Basically, all that needs to be
        # done here is for the Stream data to be returned to Scan, where it
        # will be recorded for the user.
        return self._stream
