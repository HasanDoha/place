# PLACE Interfaces

Due to the sheer number of options available in PLACE, operating it via the
command-line interface, while possible, is cumbersome. In order to provide
users with easy access to all PLACE options, a web interface has been
developed. The web interface runs in JavaScript, making it well supported
across operating systems. However, to ease in the development of JavaScript,
the programming language [Elm](https://elm-lang.org) is highly recommended. Elm
is a functional programming language with static type checking that can be easily
compiled to JavaScript.

## Brief Elm introduction

Elm is probably new to most users of PLACE and, being a functional language, it
will appear different from many languages you have encountered in the past.
Rest assured, though, that our goal is not to teach you to program in Elm, but
rather to give you some simple tools for constructing basic user interfaces
using Elm.

As the term implies, functional languages treat everything as a function. Look
at a simple statement like:

    x = 1

This does not create a variable named `x` and give it the value `1`. Instead,
this creates a function named `x` that takes no inputs and always produces `1`.
Thus we cannot change the value of `x` to something else. It is this
differentiation that usually causes the most confustion, but you will get used
to it quickly.

When a function take arguments, they are simply listed after the function name.
Like this:

    squareThis number = number * number

In this example, `squareThis` is the function name, `number` is the argument.
In Python, this would essentially be the same code as this:

    def squareThis(number):
        return number * number

Okay, that's a good start. The only other thing I want you to know right now is
that we often will explicitly list the types being used in a function. So, you
will often see our `squareThis` function written like this:

    squareThis : Float -> Float
    squareThis number = number * number

The 'type line' just tells us that this function takes in one floating point
value and produces a new one. To compare, our simple `x = 1` line would have a
type line like `x : Int` to tell us that it took in nothing and produced an
integer.

My best advice at this point is just to move on. This won't make complete sense
now, but you will usually have plenty of examples to use so it doesn't matter.

## Making HTML with Elm

The main reason PLACE uses Elm is to produce solid JavaScript, which will in
turn produce HTML for the web interface. We will refer to the HTML as the
*view*, and it is what the user will see in their web browser. Most of our Elm
code will be used to build this.

In Elm, an HTML block has a special type, called `Html Msg`. As you can see,
this type has two words instead of just one. When you have a type with multiple
words, it is kind of like having all these types stuck together.  What this
means to us is that all the HTML generated by Elm will produce some HTML for
the user (the *HTML*) to see and some messages (the *Msg*) used to manipulate
what is displayed on the web page.  For instance, when they see an HTML button,
they can click it and generate a *message*.

The *messages* generated by the user will update a *model* that sits inside the
code. In PLACE, this model is typically the values your module is looking for
in the JSON config data. But if you haven't read about that yet, don't worry.

All the above concepts come together into an `Html.program`, which is just a
way to wrap up all the things Elm needs into a nice little package.

If you feel like you need to learn more about Elm, you can go through [their
tutorial](https://guide.elm-lang.org/). Otherwise, I'm going to start talking
about making a web interface for a PLACE module.

## Template module

A lot of the Elm code will start the same way, so we have included a template
to use when starting a new module. You can find it
[here](https://github.com/PALab/place/blob/master/elm/plugins/PLACETemplate.elm).

Let's quickly run through this file.

The first line defines the module. Specifying *port* at the beginning allows
our interface to communicate with PLACE.

    port module PLACETemplate exposing (main)

This is followed by standard imports, which use a similar syntax to Python.

    import Html exposing (Html)
    import Html.Events
    import Html.Attributes
    import Json.Encode
    import ModuleHelpers

The last import, `ModuleHelpers`, is a PLACE library of helpful functions.
These are used to simplify the process of writing new modules for PLACE.

At this point, we start getting into the actual code. Generally, it makes sense
to start with the *model* first. The model is the data structure that contains
variable values needed to run your device on PLACE. The template includes the
values needed by all PLACE instruments, but you can (and should) add values to
this list as needed by your instrument.

    type alias Model =
        { moduleName : String
        , className : String
        , active : Bool
        , priority : Int
        }

Now that we have a model, we need to have a way to work with the model. Elm
uses messages to do this. Each message defines an action you would like to
perform with the data model. The default messages are provided in the template,
but you will need to add additional messages to modify the values added to the
data model in the previous step.

    type Msg
        = ToggleActive
        | ChangePriority String
        | SendJson

Each message is essentially a function and can take additional arguments.
`ToggleActive` doesn't take any arguments because it just flips a boolean value
back and forth. `ChangePriority` takes a `String` as an argument because the
value will be typed by the user into the web interface.

Okay, after the data model and functions to modify the model, we wil start
seeing how all of this fits together.  The next line is a simple one.

    port jsonData : Json.Encode.Value -> Cmd msg

This line defines a function that sends data over a port.  All PLACE interfaces
need to be able to send their data (in JSON format) to PLACE so that PLACE can
provide it to the instrument during the experiment.  This is where that happens
and it will always look just like this - no need to change it.

From this point, it will start getting a bit more complicated, but don't worry
too much if it doesn't all make sense at first.

The *main* function is the heart of the Elm interface. This is what creates all
the JavaScript code to run the interface. Fortunately, the `Html` module we
imported at the beginning does all this for us. We just need to specify four
different arguments. Here is the code:

    main : Program Never Model Msg
    main =
        Html.program
            { init = ( defaultModel, Cmd.none )
            , view = \model -> Html.div [] (viewModel model)
            , update = updateModel
            , subscriptions = \_ -> Sub.none
            }

So, the four things needed by the `Html.program` function are: *init*, *view*,
*update*, and *subscriptions*.

The first argument, *init*, just tells the program the initial value of all the
variables in the data model, plus the first command to run (usually just
`Cmd.none`). For now, we just tell *init* that the initial values will be
provided by a function named *defaultModel* that we will write later.

The second argument is *view*. This needs to be set to a function that tells
Elm how to display the current data model to the user. This is probably where
most of our work needs to be done, because we will need to determine how to
generate all the HTML used to display the current values of all the
configuration settings to the user, but we also need the view to give them
options for changing the current values to other values. If you've looked at
any of the other modules in the PLACE web interface, you will see that this is
usually done by displaying a number of checkboxes, dropdown menus, and text
boxes. The current setting will display in each box and the user will be able
to change them as desired.

After the view is the *update* argument. This is where the changes made on the
web interface are processed to update the data model. Essentailly, all the
interactive components on the web interface will produce a message when the
user changes a value. This message is then sent to the update function and
changes something in the data model. Once the update is done, the *view* will
but changed to reflect the update. This probably sounds pretty complicated, but
we don't really need to think about how this all happens. We just need to know
that it *does* happen.

The final value is the *subscription*, which is not currently used by PLACE.
Just leave it the way it is. We will not cover it in this guide. In fact,
nothing in this entire function needs to be changed. The parts you will change
have been delegated to other functions.

Now let's look at the definitions for *defaultModel*, *viewModel*, and
*updateModel*, which are the implementations of *init*, *view*, and *update*.

Here is the *defaultModel*:

    defaultModel : Model
    defaultModel =
        { moduleName = "place_template"
        , className = "None"
        , active = False
        , priority = 10
        }

This should look familiar. It is basically the *Model* from the top of the
code, but with default values filled in. Here you will want to set the
`moduleName` to match the name of the Python module that accompanies your web
interface. You will also want to select a default priority. Currently,
instruments usually have a priority in the 0-100 range, and post-processing
modules hover around 1000 (so they can *post*-process) - but PLACE does not
enforce this value in any way.

Now let's look at the *viewModel*:

    viewModel : Model -> List (Html Msg)
    viewModel model =
        ModuleHelpers.title "PLACETemplate" model.active ToggleActive
            ++ if model.active then
                [ ModuleHelpers.integerField "Priority" model.priority ChangePriority ]
               else
                [ ModuleHelpers.empty ]

This is where all our HTML code is produced. Because HTML can be complicated, a
lot of work has been done recently to streamline this process. The
`ModuleHelpers` module contains lots of helper functions for writing the HTML
parts, as we will see.

We can see from the function definition the this function is provided with the
current data model, named *model*, and produces a list of `Html Msg`
(essentially meaning it produces both HTML and messages).

Most modules will be able to use the `ModuleHelpers.title` function to begin
the `viewModel` function. `title` takes three arguments; the name of your web
interface, the variable used to determine if the module is *active* or not, and
the message used to activate/deactivate your module. If you kept the `active`
variable in your model the same, we have shown here, you can leave this line
the same - just change the name of the interface.

After the title, we use the `++` operation to *append* some more stuff to the
`List (Html Msg)` we are building. But we only want to append this stuff if the
module is active, so we use an `if` statement. In Elm, `if` statements use an
`if`/`then`/`else` syntax. In the `else` part, we see that if the model is not
active, we will just append an empty list (technically it appends an empty text
string). If the model *is* active, however, we will display an integer field,
where the user can enter an integer value. This field will be labelled
"Priority" on the web interface, it will be associated with the
`model.priority` value, and `ChangePriority` is the message used to change the
value. By passing these three things to `ModuleHelpers.integerField`, the
function will be able to construct the rest of the HTML needed to display the
field in the web interface. Here is what the same code would look like if we
didn't have the helper function:

    Html.p []
        [ Html.text ("Priority ++ ": ")
        , Html.input
            [ Html.Attributes.value (toString model.priority)
            , Html.Attributes.type_ "number"
            , Html.Events.onInput ChangePriority
            ]
            []
        ]

So, technically, we aren't saving that much, but there are a lot of complicated
HTML calls to make in there that can be hard to remember, so having these
helper functions is useful while you are new to making modules. Just keep in
mind that you can always construct interfaces using the full set of HTML tags
if you would like!

These helper functions are new (as of writing this), but we already have
helpers for checkboxes, integers, floats, and strings. By the time you read
this, there should be one written for dropdown menus, too. Check the
`ModuleHelpers.elm` in the `place/elm/plugins/` directory for the latest
offering.

The last piece of the puzzle is the *updateModel* function.

    updateModel : Msg -> Model -> ( Model, Cmd Msg )
    updateModel msg model =
        case msg of
            ToggleActive ->
                if model.active then
                    updateModel SendJson
                        { model
                            | className = "None"
                            , active = False
                        }
                else
                    updateModel SendJson
                        { model
                            | className = "PLACETemplate"
                            , active = True
                        }

            ChangePriority newPriority ->
                updateModel SendJson
                    { model
                        | priority = Result.withDefault 10 (String.toInt newPriority)
                    }

            SendJson ->
                ( model
                , jsonData
                    (Json.Encode.list
                        [ Json.Encode.object
                            [ ( "module_name", Json.Encode.string model.moduleName )
                            , ( "class_name", Json.Encode.string model.className )
                            , ( "priority", Json.Encode.int model.priority )
                            , ( "config"
                              , Json.Encode.object
                                    []
                              )
                            ]
                        ]
                    )
                )

In this function, we just have to write the code for each of our messages. So
we start with a `case` statement and then list each message. Let's take a
moment and explain what's happening in the three messages provided by this
template.

`ToggleActive` is the first one.  If `ToggleActive` corresponded a normal
boolean value, we could simply have written:

    ToggleSomething -> updateModel SendJson { model | something = not model.something }

This can be read as:

> "Update the model and send JSON data for the current model such that
> something is now not something."

You can use this for most boolean configuration values, but `ToggleActive` is a
bit different. When we set `model.active` to `False` we also need to set
`className` to `None`. PLACE enforces this convention. So, when you are writing
your own module, you can take the `ToggleActive` code directly from this file,
just change the `className` to match the one in the Python module. If you have
more than one class in your module, you will need to take a more advanced
approach that is not covered here.


The `SendJson` message is a special one, because it handles syncing up the data
with PLACE. The entire data model is encoded into JSON and the JSON is sent
over a port to PLACE. We will talk about this more later.

So that's it! From here, we will explore adapting this interface for your own devices.

## Starting your own module


## To be continued...
